<!DOCTYPE html>
<html lang="en">
  <head>
    <title>ctk three.js viewer</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        background-color: #fff;
        margin: 0px;
        overflow: hidden;
      }

      #info {
        position: absolute;
        color: #ffffff;
        top: 0px;a
        width: 100%;
        padding: 5px;
        font-family:Monospace;
        font-size:13px;
        text-align:center;
      }
      a {
        color: #fff;
      }
    </style>
  </head>

  <body>

    <div id="container"></div>

    <div id="info"><a href="https://threejs.org" target="_blank">three.js</a> - fat lines</div>

    <script src="build/three.js"></script>
    <script src="js/controls/OrbitControls.js"></script>

    <script src="js/WebGL.js"></script>

    <script src='js/libs/dat.gui.min.js'></script>

    <script src='js/lines/LineSegmentsGeometry.js'></script>
    <script src='js/lines/LineGeometry.js'></script>
    <script src='js/lines/WireframeGeometry2.js'></script>

    <script src='js/lines/LineMaterial.js'></script>

    <script src='js/lines/LineSegments2.js'></script>
    <script src='js/lines/Line2.js'></script>
    <script src='js/lines/Wireframe.js'></script>

    <script src='./input.json'></script>

    <script>

      if ( WEBGL.isWebGLAvailable() === false ) {

        document.body.appendChild( WEBGL.getWebGLErrorMessage() );

      }

      var line, renderer, scene, camera, camera2, controls;
      var line1;
      var matLine, matLineBasic, matLineDashed;

      // viewport
      var insetWidth;
      var insetHeight;

      init();
      animate();

      function init() {

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setClearColor( 0x000000, 0.0 );
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );

        scene = new THREE.Scene();
        // scene.background = new THREE.Color( 0xf5f5f5 );

        camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 1000 );
        camera.position.set( - 200, 100, -100 );

        var w = window.innerHeight / 4
        // camera2 = new THREE.OrthographicCamera( w/-4, w/4, w/4, w/-4, 1, 1000 );
        //camera2.position.copy( camera.position );

        controls = new THREE.OrbitControls( camera, renderer.domElement );
        controls.minDistance = 10;
        controls.maxDistance = 500;

        parentTransform = new THREE.Object3D();
        for ( var i = 0; i < DATA.length; i ++ ) {
          var lineGeometry = new THREE.BufferGeometry();
          var points = [];
          var coords = DATA[i].coords;
          for (var j = 0; j < coords.length; j++) {
            points.push(coords[j][0], coords[j][1], -coords[j][2])
          }

          matLine = new THREE.LineBasicMaterial( {
            color: DATA[i].color,
            linewidth: 5, // in pixels
          } );

          lineGeometry.addAttribute( 'position', new THREE.Float32BufferAttribute( points, 3 ) );
          object = new THREE.Line( lineGeometry, matLine );
          parentTransform.add( object );
        }

        var bbox = new THREE.Box3().setFromObject(parentTransform)
        var bbCenter = bbox.getCenter(new THREE.Vector3())
        parentTransform.position.x = bbCenter.x
        parentTransform.position.y = -bbCenter.y
        parentTransform.position.z = -bbCenter.z

        scene.add( parentTransform );

        // Position and Color Data

        var positions = [];
        var colors = [];

        var points = [];
        var pointlist = DATA[0].coords;

        for (var i=0; i < pointlist.length; i++) {
          p = new THREE.Vector3(pointlist[i][0], pointlist[i][1], pointlist[i][2]);
          points.push(p);
        }

        var spline = new THREE.CatmullRomCurve3( points );
        var divisions = Math.round( 12 * points.length );
        var color = new THREE.Color(DATA[0].color);

        for ( var i = 0, l = divisions; i < l; i ++ ) {

          var point = spline.getPoint( i / l );
          positions.push( point.x, point.y, point.z );

          color.setHSL( 1.0, 1.0, 0.5 );
          colors.push( color.r, color.g, color.b );

        }

        // THREE.Line2 ( LineGeometry, LineMaterial )

        var geometry = new THREE.LineGeometry();
        geometry.setPositions( positions );
        geometry.setColors( colors );

        matLine = new THREE.LineMaterial( {

          color: 0xffffff,
          linewidth: 10, // in pixels
          vertexColors: THREE.VertexColors,
          //resolution:  // to be set by renderer, eventually
          dashed: false

        } );

        line = new THREE.Line2( geometry, matLine );
        line.computeLineDistances();
        line.scale.set( 1, 1, 1 );
        // scene.add( line );

        window.addEventListener( 'resize', onWindowResize, false );
        onWindowResize();

      }

      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

        insetWidth = window.innerHeight / 2; // square
        insetHeight = window.innerHeight / 2;

        // camera2.aspect = insetWidth / insetHeight;
        // camera2.updateProjectionMatrix();

      }

      function animate() {

        requestAnimationFrame( animate );

        // main scene

        // renderer.setClearColor( 0xf5f5f5, 1 );
        renderer.setClearColor( 0xffffff, 1 );

        renderer.setViewport( 0, 0, window.innerWidth, window.innerHeight );

        // renderer will set this eventually
        matLine.resolution.set( window.innerWidth, window.innerHeight ); // resolution of the viewport

        renderer.render( scene, camera );

      }

    </script>

  </body>

</html>
